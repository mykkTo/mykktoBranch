---
title: 项目-尚融宝-01-金融背景及其后端搭建
author: mykk
top: false
cover: false
toc: true
mathjax: false
summary: 本篇主要对金融项目只是的一些简单学习，以及前后端项目搭建（架构选型）
tags:
  - springboot
  - vue
  - nginx
categories:
  - 项目-尚融宝
abbrlink: a6407b24
reprintPolicy: cc_by
date: 2022-04-26 23:11:33
coverImg:
img:
password:
---







## 〇、[主目录总纲](/posts/73b5f9d8)

## Ⅰ、项目概念

### 一、项目简介

#### 1、项目说明

尚融宝是一个网络借贷信息中介服务平台，为个人投资者、个人融资用户和小微企业提供专业的线上信贷及出借撮合服务。

行业案例：人人贷 <https://www.renrendai.com/>、拍拍贷 <https://www.paipaidai.com/>

#### 2、项目架构图

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/0d2630acf4428d33859d89e8f78be575.png)

#### 3、业务流程图

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/27528777bac0634fd778ca60094057b4.png)

### 二、开发环境和技术栈

#### 1、技术栈-后端



- SpringBoot 2.3.4.RELEASE
- SpringCloud Hoxton.SR8：微服务基础设施 - 服务注册、服务发现、服务熔断、微服务网关、配置中心等
- SpringCloud Alibaba 2.2.2.RELEASE
- MyBatis Plus：持久层框架和代码生成器
- Lombok：简化实体类开发
- Swagger2：Api接口文档生成工具
- Logback：日志系统
- alibaba-easyexcel：Excel读写
- Spring Data Redis：Spring项目中访问Redis缓存
- HTTPClient: 基于Http协议的客户端，用来实现远程调用
- Spring Task：定时任务

#### 2、技术栈-前端

- Node.js： JavaScript 运行环境
- ES6：JavaScript的模块化版本
- axios：一个发送Ajax请求的工具
- Vue.js：web 界面的渐进式框架
- Element-UI：前端组件库
- 模块化开发：解决javascript变量全局空间污染的问题
- NPM：模块资源管理器
- vue-element-admin：基于Vue.js的后台管理系统UI集成方案
- NuxtJS：基于Vue.js构建的服务器端渲染应用的轻量级框架

#### 3、中间件

- MySQL 5.7：关系型数据库     
- Redis 5.0：缓存技术     
- RabbitMQ 3.8：消息中间件



#### 4、第三方接口

- 阿里云短信：短信网关
- 阿里云OSS：分布式文件存储
- 资金托管平台API对接：汇付宝



#### 5、开发环境

- jdk 1.8

- maven 3.6

- ideaIU-2020.2.3：
- 插件：lombok、MyBatisX



### 三、金融知识普及

#### 1、信用贷款平台的类别

##### 1、银行系

- 优势：
  - 第一，资金雄厚，流动性充足；
  - 第二，项目源质地优良，大多来自于银行原有中小型客户；
  - 第三，风险控制能力强。如恒丰银行、招商银行等旗下都有信用贷款平台。
- 劣势：收益率偏低，预期年化收益率处于5.5%-8.6%之间，略高于银行其他理财产品，对投资人吸引力有限。



##### 2、国资系

- 优势：
  - 拥有国有背景股东的隐性背书，兑付能力有保障，业务模式较为规范，从业人员金融专业素养较高。
- 劣势：
  - 缺乏互联网基因；项目标的较大，起投门槛较高；且产品种类有限，多为企业信用贷；
  - 较为谨慎，层层审核的机制严重影响了平台运营效率；收益率不具有吸引力。



##### 3、民营系

民营系平台数量最多，起步最早，但鱼龙混杂，不胜枚举。

- 优势：
  - 普惠金融，手续便捷；门槛极低，投资起点低最低起投门槛甚至50元；
  - 强大的互联网思维，产品创新能力高，市场化程度高；收益率高，投资收益率具有吸引力。
- 劣势：
  - 风险偏高，资本实力及风控能力偏弱，跑路及倒闭的高发区。



#### 2、业务流程

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/20220427203134.png)

##### 1、投资人

希望在平台上找到合适的投资项目，获取利润回报的用户

##### 2、借款人

需要资金周转的用户

##### 3、资金池风险

- 资金池：一个大池子放钱，一边存进来（入水管），一边贷出去（出水管）。不管是张三的钱、李四的钱、还是王五的钱，只要进到池子里，就都叫池子的钱了。银行就是典型的资金池。

- 资金池风险：

- - 第一种情况：投资入水管流量过大，池子里全是水。这种情况，平台亏钱，干不长。原因很简单，池子里的钱是有成本的，只进不出，没有利差，拿什么钱付投资人的利息，时间长了，就只能用投资人的本金还投资人的利息，借新还旧，庞氏骗局。<font color ='red'>这个过程就直接背离了平台信息中介的身份，而成了与银行类似的金融机构。</font>
  - 第二种情况：突然来了这么多钱，怎么办？只能把放贷出水管的流量调大。放贷的这条出水管上有两个阀门，一个叫找项目，一个叫做<font color ='red'>风控</font>。遇到这种情况，经常就是两个阀门一块儿放，钱是贷出去了，但由于放松了对风险的把控，能不能再流回来，就不好说了，危险。
  - 第三种情况：提款的出水管流量变大。比如，一个黑天鹅事件，一个负面新闻，一个平台垮了，都可能诱发这种情况，这就是<font color ='red'>挤兑</font>。比如说某租宝事件后，不只这一家平台，很多其他平台的用户，也在疯狂的提现，有可能一直提到关门为止。
  - 第四种情况最极端：平台把池子里的钱都提出来，走人。这个就不用解释了，就是 <font style="color: #FF0000;">跑路。</font>
  -  <font style="color: #FF0000;">以上四种情况就是资金池最主要的几个风险——经营不善，风险失控，挤兑和跑路。银监会发布的《网络借贷信息中介机构业务活动管理暂行办法》让资金存管成为网贷平台的硬性要求，同时降低了平台建立资金池、挪用用户资金的风险。</font>

##### 4、资金托管平台

- 第三方存管模式：“第三方存管”的全称是“客户交易结算资金第三方存管”。这里的第三方存管机构，目前是指具备第三方存管资格的商业银行。银行的流入资金成本低，风控体系较完善，资金池子足够大，而且是国家背书，不会跑路。
- <font style="color: #FF0000;">说明：由于我们是教学使用，无法申请到正式的资金托管平台的支持，所以我们根据资金托管平台API接口文档，自行开发模拟一套API接口来满足业务需要，业务过程与实际开发基本一致。</font>







## Ⅱ、后端架构搭建

### 一、接口工程创建

#### 1、创建父工程 BackEndCode

##### 1、创建 maven 项目

<font color='red'>Group：com.kk</font>

<font color='red'>Artifact：BackEndCode</font>

##### 2、删除src目录



##### 3、配置SpringBoot版本

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.4.RELEASE</version>
</parent>
```



##### 4、**配置pom依赖版本号**

```xml
<properties>
    <java.version>1.8</java.version>
    <spring-cloud-alibaba.version>2.2.2.RELEASE</spring-cloud-alibaba.version>
    <spring-cloud.version>Hoxton.SR8</spring-cloud.version>
    <mybatis-plus.version>3.4.1</mybatis-plus.version>
    <velocity.version>2.0</velocity.version>
    <swagger.version>2.9.2</swagger.version>
    <swagger-bootstrap-ui.version>1.9.2</swagger-bootstrap-ui.version>
    <commons-lang3.version>3.9</commons-lang3.version>
    <commons-fileupload.version>1.3.1</commons-fileupload.version>
    <commons-io.version>2.6</commons-io.version>
    <alibaba.easyexcel.version>2.1.1</alibaba.easyexcel.version>
    <apache.xmlbeans.version>3.1.0</apache.xmlbeans.version>
    <fastjson.version>1.2.28</fastjson.version>
    <gson.version>2.8.2</gson.version>
    <json.version>20170516</json.version>
    <aliyun-java-sdk-core.version>4.3.3</aliyun-java-sdk-core.version>
    <aliyun-sdk-oss.version>3.10.2</aliyun-sdk-oss.version>
    <jodatime.version>2.10.1</jodatime.version>
    <jwt.version>0.7.0</jwt.version>
    <httpclient.version>4.5.1</httpclient.version>
</properties>
```





##### 5、配置pom依赖

```xml
    <dependencyManagement>
        <dependencies>
            <!--Spring Cloud-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!--Spring Cloud Alibaba-->
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${spring-cloud-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

            <!--mybatis-plus-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatis-plus.version}</version>
            </dependency>
            <!--mybatis-plus 代码生成器-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-generator</artifactId>
                <version>${mybatis-plus.version}</version>
            </dependency>
            <!-- Mybatis Plus 代码生成器模板引擎,  -->
            <dependency>
                <groupId>org.apache.velocity</groupId>
                <artifactId>velocity-engine-core</artifactId>
                <version>${velocity.version}</version>
            </dependency>

            <!--swagger-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>${swagger.version}</version>
            </dependency>
            <!--swagger ui-->
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger-ui</artifactId>
                <version>${swagger.version}</version>
            </dependency>
            <!--swagger-bootstrap-ui-->
            <dependency>
                <groupId>com.github.xiaoymin</groupId>
                <artifactId>swagger-bootstrap-ui</artifactId>
                <version>${swagger-bootstrap-ui.version}</version>
            </dependency>

            <!--commons-lang3-->
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>${commons-lang3.version}</version>
            </dependency>

            <!--文件上传-->
            <dependency>
                <groupId>commons-fileupload</groupId>
                <artifactId>commons-fileupload</artifactId>
                <version>${commons-fileupload.version}</version>
            </dependency>

            <!--commons-io-->
            <dependency>
                <groupId>commons-io</groupId>
                <artifactId>commons-io</artifactId>
                <version>${commons-io.version}</version>
            </dependency>

            <!--excel解析-->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>easyexcel</artifactId>
                <version>${alibaba.easyexcel.version}</version>
            </dependency>
            <!--excel解析依赖-->
            <dependency>
                <groupId>org.apache.xmlbeans</groupId>
                <artifactId>xmlbeans</artifactId>
                <version>${apache.xmlbeans.version}</version>
            </dependency>

            <!--json-->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>${fastjson.version}</version>
            </dependency>
            <dependency>
                <groupId>org.json</groupId>
                <artifactId>json</artifactId>
                <version>${json.version}</version>
            </dependency>
            <dependency>
                <groupId>com.google.code.gson</groupId>
                <artifactId>gson</artifactId>
                <version>${gson.version}</version>
            </dependency>

            <!--阿里云SDK远程调用-->
            <dependency>
                <groupId>com.aliyun</groupId>
                <artifactId>aliyun-java-sdk-core</artifactId>
                <version>${aliyun-java-sdk-core.version}</version>
            </dependency>

            <!--阿里云文件管理-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>${aliyun-sdk-oss.version}</version>
            </dependency>

            <!--日期时间工具-->
            <dependency>
                <groupId>joda-time</groupId>
                <artifactId>joda-time</artifactId>
                <version>${jodatime.version}</version>
            </dependency>

            <!--jwt工具-->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>${jwt.version}</version>
            </dependency>

            <!--httpclient-->
            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
                <version>${httpclient.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
```



#### 2、创建模块kk-common

##### 1、创建Maven模块

在 <font color='red'>父工程</font> 下创建普通maven模块

<font color='red'>Group：com.kk</font>

<font color='red'>Artifact：kk-common</font>

##### 2、配置pom

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!--lombok用来简化实体类：需要安装lombok插件-->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
</dependencies>
```





#### 3、创建模块service-base

##### 1、创建Maven模块

在 <font color='red'>父工程</font> 下创建普通maven模块

<font color='red'>Group：com.kk</font>

<font color='red'>Artifact：service-base</font>

##### 2、配置pom

<font color='red'>注意：</font>依赖kk-common

```xml
    <dependencies>
        <dependency>
            <groupId>com.kk</groupId>
            <artifactId>service-base</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
    <!--swagger-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
        </dependency>
        <!--swagger ui-->
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
        </dependency>
    </dependencies>
```



#### 4、创建模块service-core

##### 1、创建Maven模块

在 <font color='red'>父工程</font> 下创建普通maven模块

<font color='red'>Group：com.kk</font>

<font color='red'>Artifact：service-core</font>

##### 2、配置pom

<font color='red'>注意：</font>依赖kk-common

```xml
    <dependencies>
        <dependency>
            <groupId>com.kk</groupId>
            <artifactId>service-base</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>
        <!--mysql-->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <!--mybatis-plus-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
        </dependency>
        <!--mybatis-plus 代码生成器-->
        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-generator</artifactId>
        </dependency>
        <!-- Mybatis Plus 代码生成器模板引擎,  -->
        <dependency>
            <groupId>org.apache.velocity</groupId>
            <artifactId>velocity-engine-core</artifactId>
        </dependency>
    </dependencies>
```



#### 5、代码生成器



##### 1、创建数据库

<font color='red'>创建数据库srb_core</font>

<font color='red'>并执行sql脚本初始化数据结构和数据</font>

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/20220427223135.png)

##### 2、创建代码生成器

在test目录中创建测试用例，并执行

```java
package com.kk.srb.core;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
import org.junit.Test;

public class CodeGenerator {
    @Test
    public void genCode() {

        // 1、创建代码生成器
        AutoGenerator mpg = new AutoGenerator ( );

        // 2、全局配置
        GlobalConfig gc = new GlobalConfig ( );
        String projectPath = System.getProperty ("user.dir");
        gc.setOutputDir (projectPath + "/src/main/java");
        gc.setAuthor ("mykk");
        gc.setOpen (false); //生成后是否打开资源管理器
        gc.setServiceName ("%sService");    //去掉Service接口的首字母I
        gc.setIdType (IdType.AUTO); //主键策略
        gc.setSwagger2 (true);//开启Swagger2模式
        mpg.setGlobalConfig (gc);

        // 3、数据源配置
        DataSourceConfig dsc = new DataSourceConfig ( );
        dsc.setUrl ("jdbc:mysql://121.4.120.62:3306/srb_core?serverTimezone=GMT%2B8&characterEncoding=utf-8");
        dsc.setDriverName ("com.mysql.cj.jdbc.Driver");
        dsc.setUsername ("root");
        dsc.setPassword ("root");
        dsc.setDbType (DbType.MYSQL);
        mpg.setDataSource (dsc);

        // 4、包配置
        PackageConfig pc = new PackageConfig ( );
        pc.setParent ("com.kk.srb.core");
        pc.setEntity ("pojo.entity"); //此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。
        mpg.setPackageInfo (pc);

        // 5、策略配置
        StrategyConfig strategy = new StrategyConfig ( );
        strategy.setNaming (NamingStrategy.underline_to_camel);//数据库表映射到实体的命名策略

        strategy.setColumnNaming (NamingStrategy.underline_to_camel);//数据库表字段映射到实体的命名策略
        strategy.setEntityLombokModel (true); // lombok
        strategy.setLogicDeleteFieldName ("is_deleted");//逻辑删除字段名
        strategy.setEntityBooleanColumnRemoveIsPrefix (true);//去掉布尔值的is_前缀（确保tinyint(1)）
        strategy.setRestControllerStyle (true); //restful api风格控制器
        mpg.setStrategy (strategy);

        // 6、执行
        mpg.execute ( );
    }
}
```



##### 



#### 6、启动应用程序



##### 1、创建application.yml

```yml
server:
  port: 8110 # 服务端口

spring:
  profiles:
    active: dev # 环境设置
  application:
    name: service-core # 服务名
  datasource: # mysql数据库连接
    type: com.zaxxer.hikari.HikariDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://121.4.120.62:3306/srb_core?serverTimezone=GMT%2B8&characterEncoding=utf-8
    username: root
    password: root

mybatis-plus: #mybatis
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  mapper-locations: classpath:com/kk/srb/core/mapper/xml/*.xml

```





##### 2、创建SpringBoot配置文件

在service-core中创建config包，创建MybatisPlusConfig类

```java
package com.kk.srb.core.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.annotation.EnableTransactionManagement;

@Configuration
@MapperScan("com.kk.srb.core.mapper")
@EnableTransactionManagement //事务处理
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor ( );
        interceptor.addInnerInterceptor (new PaginationInnerInterceptor (DbType.MYSQL));//分页
        return interceptor;
    }
}

```



##### 3、创建SpringBoot启动类

<font color='red'>注意：</font>扫描com.kk.srb

```java
package com.kk.srb.core;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan({"com.kk.srb"})
public class ServiceCoreApplication {

    public static void main(String[] args) {
        SpringApplication.run (ServiceCoreApplication.class, args);
    }
}

```



##### 4、运行启动类

查看控制台8110端口是否成功启动



#### 7、整体代码结构图

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/20220427223747.png)





### 二、积分等级CRUD



#### 1、积分等级列表接口

##### 1、编写积分等级管理接口

在controller中添加admin包，添加AdminIntegralGradeController类

```java
package com.kk.srb.core.controller.admin;

import com.kk.srb.core.pojo.entity.IntegralGrade;
import com.kk.srb.core.service.IntegralGradeService;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import java.util.List;

@CrossOrigin//允许可访问的域列表
@RestController
@RequestMapping("/admin/core/integralGrade")
public class AdminIntegralGradeController {

    @Resource
    private IntegralGradeService integralGradeService;

    @GetMapping("/list")
    public List<IntegralGrade> listAll() {
        return integralGradeService.list ( );
    }
}

```



##### 2、测试

重启服务，访问： <http://localhost:8110/admin/core/integralGrade/list>  查看结果json数据



#### 2、逻辑删除接口

##### 1、添加删除方法

AdminIntegralGradeController添加removeById方法

```java
@DeleteMapping("/remove/{id}")
public boolean removeById(@PathVariable Long id){
    return integralGradeService.removeById(id);
}
```



##### 2、使用postman测试删除

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202204282149807.png)



#### 3、配置Swagger2

##### 1、Swagger2配置文件

在service-base中创建Swagger2Config

```java
package com.kk.srb.core.config;

import com.google.common.base.Predicates;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

@Configuration
@EnableSwagger2
public class Swagger2Config {
    @Bean
    public Docket adminApiConfig() {

        return new Docket (DocumentationType.SWAGGER_2)
                .groupName ("adminApi")
                .apiInfo (adminApiInfo ( ))
                .select ( )
                //只显示admin路径下的页面
                .paths (Predicates.and (PathSelectors.regex ("/admin/.*")))
                .build ( );

    }

    private ApiInfo adminApiInfo() {

        return new ApiInfoBuilder ( )
                .title ("尚融宝后台管理系统-API文档")
                .description ("本文档描述了尚融宝后台管理系统接口")
                .version ("1.0")
                .contact (new Contact ("Helen", "http://mykkto.cn", "763856958@qq.com"))
                .build ( );
    }
}

```

##### 2、查看Swagger文档

重启服务器查看接口文档：[http://localhost:8110/swagger-ui.html](http://localhost:8101/swagger-ui.html)



##### 3、常见注解

**实体类注解：**entity的实体类中可以添加一些自定义设置，例如：

```java
@ApiModelProperty(value = "创建时间", example = "2019-01-01 8:00:00")
private LocalDateTime createTime;

@ApiModelProperty(value = "更新时间", example = "2019-01-01 8:00:00")
private LocalDateTime updateTime;
```



**controller注解：**

定义在类上

```java
@Api(tags = "积分等级管理")
```

定义在方法上

```java
@ApiOperation("积分等级列表")

@ApiOperation(value = "根据id删除积分等级", notes = "逻辑删除")
```

定义在参数上

```java
@ApiParam(value = "数据id", required = true, example = "100")
```



### 三、统一返回结果

#### 1、数据格式的定义

项目中我们会将响应封装成json返回，一般我们会将所有接口的数据格式统一， 使前端对数据的操作更一致、轻松。

一般情况下，统一返回数据格式没有固定的格式，只要能描述清楚返回的数据状态以及要返回的具体数据就可以。但是一般会包含状态码、返回消息、数据这几部分内容

例如，我们的系统要求返回的基本数据格式如下：

**成功：**

```json
   {
      "code": 0,
      "message": "成功",
      "data": 数据
    }
```

**失败：**

```json
{
  "code": -1,
  "message": "失败",
  "data": null
}
```



因此，我们定义统一结果

```json
{
  "code": 数字, //业务响应码
  "message": 字符串, //返回消息
  "data": 对象 //返回数据
}
```



#### 2、创建枚举

在kk-common中创建result包，创建枚举 ResponseEnum

```java
package com.kk.common.result;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

@Getter
@AllArgsConstructor
@ToString
public enum ResponseEnum {
    SUCCESS (0, "成功"),
    ERROR (-1, "服务器内部错误");

    // 响应状态码
    private Integer code;
    // 响应信息
    private String message;
}

```



#### 3、定义同统一结果类

```java
package com.kk.common.result;

import lombok.Data;

import java.util.HashMap;
import java.util.Map;

@Data
public class R {

    private Integer code;

    private String message;

    private Map<String, Object> data = new HashMap ( );

    /**
     * 构造器私有
     */
    private R() {
    }

    /**
     * 返回成功
     */
    public static R ok() {
        R r = new R ( );
        r.setCode (ResponseEnum.SUCCESS.getCode ( ));
        r.setMessage (ResponseEnum.SUCCESS.getMessage ( ));
        return r;
    }

    /**
     * 返回失败
     */
    public static R error() {
        R r = new R ( );
        r.setCode (ResponseEnum.ERROR.getCode ( ));
        r.setMessage (ResponseEnum.ERROR.getMessage ( ));
        return r;
    }

    /**
     * 设置特定结果
     */
    public static R setResult(ResponseEnum responseEnum) {
        R r = new R ( );
        r.setCode (responseEnum.getCode ( ));
        r.setMessage (responseEnum.getMessage ( ));
        return r;
    }

    public R message(String message) {
        this.setMessage (message);
        return this;
    }

    public R code(Integer code) {
        this.setCode (code);
        return this;
    }

    public R data(String key, Object value) {
        this.data.put (key, value);
        return this;
    }

    public R data(Map<String, Object> map) {
        this.setData (map);
        return this;
    }
}

```



#### 4、使用统一返回结果

##### 1、修改listAll

```java
    @GetMapping("/list")
    @ApiOperation("积分等级列表")
    public List<IntegralGrade> listAll() {
        return integralGradeService.list ( );
    }
```



##### 2、修改removeById

```java
    @ApiOperation(value = "根据id删除积分等级", notes = "逻辑删除")
    @DeleteMapping("/remove/{id}")
    public R removeById(
            @ApiParam(value = "数据id", required = true, example = "1")
            @PathVariable Long id) {
        boolean result = integralGradeService.removeById (id);
        if (result) {
            //return R.setResult(ResponseEnum.UPLOAD_ERROR);
            return R.ok ( ).message ("删除成功");
        } else {
            return R.error ( ).message ("删除失败");
        }
    }
```



##### 3、新增数据

```java
    @ApiOperation("新增积分等级")
    @PostMapping("/save")
    public R save(
            @ApiParam(value = "积分等级对象", required = true)
            @RequestBody IntegralGrade integralGrade) {
        boolean result = integralGradeService.save (integralGrade);
        if (result) {
            return R.ok ( ).message ("保存成功");
        } else {
            return R.error ( ).message ("保存失败");
        }
    }
```



##### 4、根据id查询

```java
    @ApiOperation("根据id获取积分等级")
    @GetMapping("/get/{id}")
    public R getById(
            @ApiParam(value = "数据id", required = true, example = "1")
            @PathVariable Long id
    ) {
        IntegralGrade integralGrade = integralGradeService.getById (id);
        if (integralGrade != null) {
            return R.ok ( ).data ("record", integralGrade);
        } else {
            return R.error ( ).message ("数据不存在");
        }
    }
```



##### 5、根据id修改

```java
    @ApiOperation("更新积分等级")
    @PutMapping("/update")
    public R updateById(
            @ApiParam(value = "积分等级对象", required = true)
            @RequestBody IntegralGrade integralGrade) {
        boolean result = integralGradeService.updateById (integralGrade);
        if (result) {
            return R.ok ( ).message ("修改成功");
        } else {
            return R.error ( ).message ("修改失败");
        }
    }
```



### 四、统一异常处理



#### 1、**项目中的异常**

##### 1、制造异常

屏蔽 IntegralGrade 中的 @TableField注解

```java
@ApiModelProperty(value = "逻辑删除(1:已删除，0:未删除)")
//@TableField("is_deleted")
@TableLogic
private Boolean deleted;
```



##### 2、Swagger中测试

测试列表查询功能，查看结果，<font color ='red'>发生错误，显示响应失败</font>

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205042147886.png)



#### 2、统一异常处理

<font color ='red'>目标：我们想让异常结果也显示为统一的返回结果对象，并且统一处理系统的异常信息，那么需要进行统一异常处理。</font>

##### 1、创建统一异常处理器

kk-common中创建exception包，创建统一异常处理器类UnifiedExceptionHandler

```java
package com.kk.common.exception;

import com.kk.common.result.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@Slf4j
@Component //Spring容易自动管理
@RestControllerAdvice //在controller层添加通知。如果使用@ControllerAdvice，则方法上需要添加@ResponseBody
public class UnifiedExceptionHandler {
    /**
     * 未定义异常
     */
    @ExceptionHandler(value = Exception.class) //当controller中抛出Exception，则捕获
    public R handleException(Exception e) {
        log.error (e.getMessage ( ), e);
        return R.error ( );
    }
}

```



##### 2、service-core添加扫描

添加 "com.kk.common"

```java
@SpringBootApplication
//@MapperScan({"com.kk.srb"})// 需要指定指定路径
@ComponentScan({"com.kk.srb","com.kk.common"})
public class ServiceCoreApplication {
```



##### 3、测试

返回统一错误结果

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205042244964.png)



#### 3、处理特定异常

<font color ='red'>如果我们不想显示统一的“服务器内部错误”，需要个性化的显示异常信息，那么需要针对特定的异常做处理</font>




##### 1、**添加依赖**

在kk-common中添加jdbc依赖

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
</dependency>
```



##### 2、添加异常处理方法

在 UnifiedExceptionHandler 中添加

```java
    /**
     * 特定异常
     */
    @ExceptionHandler(BadSqlGrammarException.class)
    public R handleBadSqlGrammarException(BadSqlGrammarException e){
        log.error(e.getMessage(), e);
        return R.setResult(ResponseEnum.BAD_SQL_GRAMMAR_ERROR);
    }
```



完整枚举

```java
package com.kk.common.result;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.ToString;

@Getter
@AllArgsConstructor
@ToString
public enum ResponseEnum {
    SUCCESS (0, "成功"),
    ERROR (-1, "服务器内部错误"),

    //-1xx 服务器错误
    BAD_SQL_GRAMMAR_ERROR (-101, "sql语法错误"),
    SERVLET_ERROR (-102, "servlet请求异常"), //-2xx 参数校验
    UPLOAD_ERROR (-103, "文件上传错误"),
    EXPORT_DATA_ERROR (104, "数据导出失败"),


    //-2xx 参数校验
    BORROW_AMOUNT_NULL_ERROR (-201, "借款额度不能为空"),
    MOBILE_NULL_ERROR (-202, "手机号码不能为空"),
    MOBILE_ERROR (-203, "手机号码不正确"),
    PASSWORD_NULL_ERROR (204, "密码不能为空"),
    CODE_NULL_ERROR (205, "验证码不能为空"),
    CODE_ERROR (206, "验证码错误"),
    MOBILE_EXIST_ERROR (207, "手机号已被注册"),
    LOGIN_MOBILE_ERROR (208, "用户不存在"),
    LOGIN_PASSWORD_ERROR (209, "密码错误"),
    LOGIN_LOKED_ERROR (210, "用户被锁定"),
    LOGIN_AUTH_ERROR (-211, "未登录"),


    USER_BIND_IDCARD_EXIST_ERROR (-301, "身份证号码已绑定"),
    USER_NO_BIND_ERROR (302, "用户未绑定"),
    USER_NO_AMOUNT_ERROR (303, "用户信息未审核"),
    USER_AMOUNT_LESS_ERROR (304, "您的借款额度不足"),
    LEND_INVEST_ERROR (305, "当前状态无法投标"),
    LEND_FULL_SCALE_ERROR (306, "已满标，无法投标"),
    NOT_SUFFICIENT_FUNDS_ERROR (307, "余额不足，请充值"),

    PAY_UNIFIEDORDER_ERROR (401, "统一下单错误"),

    ALIYUN_SMS_LIMIT_CONTROL_ERROR (-502, "短信发送过于频繁"),//业务限流
    ALIYUN_SMS_ERROR (-503, "短信发送失败"),//其他失败

    WEIXIN_CALLBACK_PARAM_ERROR (-601, "回调参数不正确"),
    WEIXIN_FETCH_ACCESSTOKEN_ERROR (-602, "获取access_token失败"),
    WEIXIN_FETCH_USERINFO_ERROR (-603, "获取用户信息失败");

    // 响应状态码
    private Integer code;
    // 响应信息
    private String message;
}

```



##### 3、恢复制造的异常

```java
@TableField(value = "is_deleted")
```





#### 4、自定义异常

<font color ='red'>目标</font>：使用一个或较少的异常类，可以捕获和显示所有的异常信息。

<font color ='red'>方案</font>：因此，我们可以创建一个自定义异常类（必须是运行时异常），在程序中抛出这个自定义异常对象，并在统一异常处理器中捕获自定义异常对象

##### 1、创建自定义异常类

完整查看github源码

```java
package com.kk.common.exception;

import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
public class BusinessException extends RuntimeException {
    //状态码
    private Integer code;

    //错误消息
    private String message;
}

```

##### 2、添加异常处理方法

UnifiedExceptionHandler类中添加

```java
    /**
     * 自定义异常
     */
    @ExceptionHandler(BusinessException.class)
    public R handleBusinessException(BusinessException e){
        log.error(e.getMessage(), e);
        return R.error().message(e.getMessage()).code(e.getCode());
    }
```



##### 3、修改Controller

在AdminIntegralGradeController的方法中添加异常处理，业务中需要的位置抛出BusinessException自定义异常。

```java
@ApiOperation("新增积分等级")
@PostMapping("/save")
public R save(
    @ApiParam(value = "积分等级对象", required = true)
    @RequestBody IntegralGrade integralGrade){

    //如果借款额度为空就手动抛出一个自定义的异常！
    if(integralGrade.getBorrowAmount() == null){
        //BORROW_AMOUNT_NULL_ERROR(-201, "借款额度不能为空"),
        throw new BusinessException(ResponseEnum.BORROW_AMOUNT_NULL_ERROR);
    }

    boolean result = integrationService.save(integralGrade);
    if (result) {
        return R.ok().message("保存成功");
    } else {
        return R.error().message("保存失败");
    }
}
```



##### 4、测试

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205052210065.png)

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205052210621.png)



#### 5、异常处理优化

<font color ='red'>目标</font>：以优雅的 Assert(断言) 方式来校验业务的异常情况，消除 if else



##### 1、什么是断言

用断言的方式封装异常的抛出

```java
package com.kk.srb.core;

import org.junit.Test;
import org.springframework.util.Assert;

public class AssertTests {

    //if else的用法
    @Test
    public void test1() {
        Object o = null;
        if (o == null) {
            throw new IllegalArgumentException ("用户不存在.");
        }
    }

    //断言的用法：更为简洁
    @Test
    public void test2() {
        // 另一种写法
        Object o = null;
        Assert.notNull (o, "用户不存在.");
    }
}

```



##### 2、自定义断言

引入自定义断言，类路径：`com.kk.common.exception.Assert`

```java
@Slf4j
public class Assert {

    /**
     * 断言对象不为空
     * obj 为空则抛异常
     *
     * @param obj
     * @param responseEnum
     */
    public static void notNull(Object obj, ResponseEnum responseEnum) {
        if (obj == null) {
            log.info ("obj is null.....................");
            throw new BusinessException (responseEnum);
        }
    }
    ...........
}
```

<font color ='red'>完整的源代码</font>：Assert.java



##### 3、修改controller

在controller中用断言替换if else

```java
 Assert.notNull(integralGrade.getBorrowAmount(), ResponseEnum.BORROW_AMOUNT_NULL_ERROR);
```



#### 6、Controller上层异常

##### 1、异常分类

对异常按阶段进行分类，大体可以分成：进入Controller前的异常 和 业务层异常，具体可以参考下图：

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205052240355.png)



##### 2、处理Controller上层异常

UnifiedExceptionHandler中添加

```java
/**
     * Controller上一层相关异常
     */
@ExceptionHandler({
    NoHandlerFoundException.class,
    HttpRequestMethodNotSupportedException.class,
    HttpMediaTypeNotSupportedException.class,
    MissingPathVariableException.class,
    MissingServletRequestParameterException.class,
    TypeMismatchException.class,
    HttpMessageNotReadableException.class,
    HttpMessageNotWritableException.class,
    MethodArgumentNotValidException.class,
    HttpMediaTypeNotAcceptableException.class,
    ServletRequestBindingException.class,
    ConversionNotSupportedException.class,
    MissingServletRequestPartException.class,
    AsyncRequestTimeoutException.class
        })
public R handleServletException(Exception e) {
    log.error(e.getMessage(), e);
    //SERVLET_ERROR(-102, "servlet请求异常"),
    return R.error().message(ResponseEnum.SERVLET_ERROR.getMessage()).code(ResponseEnum.SERVLET_ERROR.getCode());
}
```





##### 3、测试

在save测试用例中输入非法的json参数，则得到下面的结果。我们可以在控制台日志中查看具体的错误原因。前端只需要返回相对简单友好的提示即可。

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205052245586.png)



### 五、统一日志处理



#### 1、Logback日志 

##### 1.什么是日志

通过日志查看程序的运行过程，运行信息，异常信息等

##### 2.日志级别

日志记录器（Logger）的行为是分等级的。如下表所示：

分为：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF

<font color ='red'>默认</font>情况下，spring boot从控制台打印出来的日志级别只有<font color ='red'>INFO及以上级别</font>，可以配置日志级别

```yml
# 设置日志级别
logging:
  level:
    root: ERROR
```

这种方式能将ERROR级别以及以上级别的日志输出到控制台上，其他级别将不会输出



##### 3.创建日志文件

spring boot内部使用Logback作为日志实现的框架。

<font color ='red'>先删除前面在application.yml中的日志级别配置</font>

resources 中创建 logback-spring.xml （默认日志文件的名字）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

</configuration>
```

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205062025917.png)



##### 4、创建测试日志输出

将以下日志输出到任意controller的方法中即可，例如list方法中

前提：类上记得加 `@Slf4j`，注入 log.info 

```java
    @GetMapping("/list")
    @ApiOperation("积分等级列表")
    public R listAll() {

        log.info ("hi i'm helen");
        log.warn ("warning!!!");
        log.error ("it's a error");

        List<IntegralGrade> list = integralGradeService.list ( );
        return R.ok ( ).data ("list", list);
    }
```





#### 2、基本配置说明

##### 1.configuration

日志配置的根节点

```xml
<configuration></configuration>
```



##### 2.contextName

<contextName>是	<configuration>的子节点。

每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用<contextName>设置成其他名字，用于区分不同的应用程序。

```xml
<contextName>kkSrb</contextName>
```



##### 3.property

<property>是	<configuration>的子节点，用来定义变量。

<property> 	有两个属性，name和value：name的值是变量的名称，value是变量的值。

通过<property>	定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。

```xml
<!-- 日志的输出目录 -->
<property name="log.path" value="D:/project/finance/srb_log/core" />

<!--控制台日志格式：彩色日志-->
<!-- magenta:洋红 -->
<!-- boldMagenta:粗红-->
<!-- cyan:青色 -->
<!-- white:白色 -->
<!-- magenta:洋红 -->
<property name="CONSOLE_LOG_PATTERN"
          value="%yellow(%date{yyyy-MM-dd HH:mm:ss}) %highlight([%-5level]) %green(%logger) %msg%n"/>

<!--文件日志格式-->
<property name="FILE_LOG_PATTERN"
          value="%date{yyyy-MM-dd HH:mm:ss} [%-5level] %thread %file:%line %logger %msg%n" />

<!--编码-->
<property name="ENCODING"
          value="UTF-8" />
```



##### 4、appender

<appender>	 是<configuration>的子节点，是负责写日志的组件

<appender>	有两个必要属性name和class：name指定appender名称，class指定appender的全限定名

<encoder>	   对日志进行格式化

<pattern>	    定义日志的具体输出格式

<charset>	    编码方式



**4.1控制台日志配置**

```xml
<!-- 控制台日志 -->
<appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
        <pattern>${CONSOLE_LOG_PATTERN}</pattern>
        <charset>${ENCODING}</charset>
    </encoder>
</appender>
```





**4.2文件日志配置** 

<file>表示日志文件的位置，如果上级目录不存在会自动创建，没有默认值。

<append>默认 true，日志被追加到文件结尾，如果是 false，服务重启后清空现存文件。

```xml
<!-- 文件日志 -->
<appender name="FILE" class="ch.qos.logback.core.FileAppender">
    <file>${log.path}/log.log</file>
    <append>true</append>
    <encoder>
        <pattern>${FILE_LOG_PATTERN}</pattern>
        <charset>${ENCODING}</charset>
    </encoder>
</appender>
```



##### 5、logger

<logger>可以是	<configuration>的子节点，用来设置某一个包或具体某一个类的日志打印级别、指定<appender>

name：	用来指定受此logger约束的某一个包或者具体的某一个类

level：	用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF。默认继承上级的级别

<logger>	可以包含零个或多个<appender-ref>元素，标识这个appender将会添加到这个logger

```xml
<!-- 日志记录器  -->
<logger name="com.kk" level="INFO">
    <appender-ref ref="CONSOLE" />
    <appender-ref ref="FILE" />
</logger>
```



##### 6、测试

测试日志记录的控制台输出、文件输出、以及日志级别

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205062051381.png)



#### 3、多环境配置

##### springProfile

在一个基于Spring boot开发的项目里，常常需要有多套环境的配置：开发，测试以及产品。

使用springProfile 可以分别配置开发（dev），测试（test）以及生产（prod）等不同的环境

```xml
<!-- 开发环境和测试环境 -->
<springProfile name="dev,test">
    <logger name="com.kk" level="INFO">
        <appender-ref ref="CONSOLE" />
    </logger>
</springProfile>

<!-- 生产环境 -->
<springProfile name="prod">
    <logger name="com.kk" level="ERROR">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </logger>
</springProfile>
```



<font color ='red'>注意</font>：需要注释原始配置

```xml
    <!-- 日志记录器  -->
    <!--<logger name="com.kk" level="INFO">-->
        <!--<appender-ref ref="CONSOLE"/>-->
        <!--<appender-ref ref="FILE"/>-->
    <!--</logger>-->
```





#### 4、滚动日志 ★

<font color ='red'>问题</font>：生产环境下，如果系统长时间运行，那么日志文件会变得越来越大，系统读取和写入日志的时间会越来越慢，严重的情况会耗尽系统内存，导致系统宕机。

<font color ='red'>解决方案</font>：可以设置滚动日志。

##### 1.设置时间滚动策略

RollingFileAppender是	Appender的另一个实现，表示滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将旧日志备份到其他文件

<rollingPolicy>是	<appender>的子节点，用来定义滚动策略。

TimeBasedRollingPolicy：	最常用的滚动策略，根据时间来制定滚动策略。

<fileNamePattern>：	包含文件名及转换符， “%d”可以包含指定的时间格式，如：%d{yyyy-MM-dd}。如果直接使用 %d，默认格式是 yyyy-MM-dd。

<maxHistory>：	可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，且<maxHistory>是6，则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除。



```xml
<appender name="ROLLING_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">

    <!--  要区别于其他的appender中的文件名字  -->
    <file>${log.path}/log-rolling.log</file>
    <encoder>
        <pattern>${FILE_LOG_PATTERN}</pattern>
        <charset>${ENCODING}</charset>
    </encoder>

    <!-- 设置滚动日志记录的滚动策略 -->
    <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
        <!-- 日志归档路径以及格式 -->
        <fileNamePattern>${log.path}/info/log-rolling-%d{yyyy-MM-dd}.log</fileNamePattern>
        <!--归档日志文件保留的最大数量-->
        <maxHistory>15</maxHistory>
    </rollingPolicy>

</appender>
```



##### 2.设置触发滚动时机

放在<rollingPolicy>的子节点的位置里面，基于实践策略的触发滚动策略

<maxFileSize>设置触发滚动条件：单个文件大于100M时生成新的文件

<font color ='red'>**注意：修改日志文件名**  </font>此时 <fileNamePattern>${log.path}/info/log-rolling-%d{yyyy-MM-dd}<font color ='red'>**.%i**</font>.log</fileNamePattern>



```xml
<timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
    <maxFileSize>1KB</maxFileSize>
</timeBasedFileNamingAndTriggeringPolicy>
```





#### 5、完整的日志配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>

    <contextName>kkSrb</contextName>

    <!-- 日志的输出目录 -->
    <property name="log.path" value="D:/project/test/srb_log/core"/>

    <!--控制台日志格式：彩色日志-->
    <!-- magenta:洋红 -->
    <!-- boldMagenta:粗红-->
    <!-- cyan:青色 -->
    <!-- white:白色 -->
    <!-- magenta:洋红 -->
    <property name="CONSOLE_LOG_PATTERN"
              value="%yellow(%date{yyyy-MM-dd HH:mm:ss}) %highlight([%-5level]) %green(%logger) %msg%n"/>

    <!--文件日志格式-->
    <property name="FILE_LOG_PATTERN"
              value="%date{yyyy-MM-dd HH:mm:ss} [%-5level] %thread %file:%line %logger %msg%n"/>

    <!--编码-->
    <property name="ENCODING"
              value="UTF-8"/>

    <!-- 控制台日志 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
            <charset>${ENCODING}</charset>
        </encoder>
    </appender>

    <!-- 文件日志 -->
    <appender name="FILE" class="ch.qos.logback.core.FileAppender">
        <file>${log.path}/log.log</file>
        <append>true</append>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>${ENCODING}</charset>
        </encoder>
    </appender>

    <appender name="ROLLING_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">

        <!--  要区别于其他的appender中的文件名字  -->
        <file>${log.path}/log-rolling.log</file>
        <encoder>
            <pattern>${FILE_LOG_PATTERN}</pattern>
            <charset>${ENCODING}</charset>
        </encoder>


        <!-- 设置滚动日志记录的滚动策略 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- 日志归档路径以及格式 -->
            <fileNamePattern>${log.path}/info/log-rolling-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <!--归档日志文件保留的最大数量-->
            <maxHistory>15</maxHistory>

            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>1KB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>

    </appender>


    <!--    <logger name="com.kk" level="INFO">-->
    <!--        <appender-ref ref="CONSOLE" />-->
    <!--        <appender-ref ref="FILE" />-->
    <!--    </logger>-->

    <!-- 开发环境和测试环境 -->
    <springProfile name="dev,test">
        <logger name="com.kk" level="INFO">
            <appender-ref ref="CONSOLE"/>
        </logger>
    </springProfile>

    <!-- 生产环境 -->
    <springProfile name="prod">
        <logger name="com.kk" level="ERROR">
            <appender-ref ref="CONSOLE"/>
            <appender-ref ref="ROLLING_FILE"/>
        </logger>
    </springProfile>
</configuration>

```





## Ⅲ、前端架构搭建

### 一、搭建前端平台

#### 1、**vue-element-admin**

vue-element-admin是基于element-ui 的一套后台管理<font color ='red'>系统集成方案</font>。

**GitHub地址：**<https://github.com/PanJiaChen/vue-element-admin>

**项目在线预览：**[https://panjiachen.gitee.io/vue-element-admin](https://panjiachen.gitee.io/vue-element-admin/#/login?redirect=%2Fdashboard)

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205062135460.png)

#### 2、**vue-admin-template**

##### 1、简介

vueAdmin-template是基于vue-element-admin的一套后台管理系统基础模板<font color ='red'>（最少精简版）</font>，可作为模板进行二次开发。

**GitHub地址：**<https://github.com/PanJiaChen/vue-admin-template>

**根据用户角色来动态生成侧边栏的分支：**<https://github.com/PanJiaChen/vue-admin-template/tree/permission-control>



##### 2、安装和运行

```bash
# clone 项目
git clone https......
# 重命名,删掉自带的 .git文件夹

# 进入目录
cd FrontEndCode

# 安装依赖
npm install

# 启动。执行后，浏览器自动弹出并访问http://localhost:9528/
npm run dev
```

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205062156091.png)



#### 3、前端配置

##### 1、禁用ESLint语法检查

vue.config.js 第30行处禁用ESLint语法检查

```js
lintOnSave: false, 
```



##### 2、添加prettier格式化配置

在vue项目根目录下新建一个文件.prettierrc

```js
{
  "semi": false,
  "singleQuote": true,
  "htmlWhitespaceSensitivity": "ignore"
}
```



##### 3、修改页面标题

src/settings.js 第3行处修改页面标题

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205062211618.png)

##### 4、国际化设置

src/main.js 第7行处修改语言

```js
import locale from 'element-ui/lib/locale/lang/zh-CN' // lang i18n
```



测试平台语言的修改

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205062329256.png)



##### 5、下拉菜单修改

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205062331557.png)

##### 6、登录页修改

src/views/login/index.vue

修改页面标题、登录按钮等



### 二、系统路由配置

#### 1、**组件定义**

##### 1、创建vue组件

在src/views文件夹下创建以下文件夹和文件

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205062339340.png)

##### 2、list.vue

core/integral-grade/list.vue

注意，最底下保留一行，不然vscode报错

```vue
<template>
  <div class="app-container">积分等级列表</div>
</template>

```



##### 3、form.vue

core/integral-grade/orm.vue

```vue
<template>
  <div class="app-container">
    积分等级表单
  </div>
</template>
```





#### 2、路由定义

修改 src/router/index.js 文件，重新定义constantRoutes，拷贝到 dashboard路由节点 下面

<font color ='red'>**注意：**每个路由的name不能相同</font>

```js
{
    path: '/core/integral-grade',
    component: Layout,
    redirect: '/core/integral-grade/list',
    name: 'coreIntegralGrade',
    meta: { title: '积分等级管理', icon: 'el-icon-s-marketing' },
    alwaysShow: true,
    children: [
      {
        path: 'list',
        name: 'coreIntegralGradeList',
        component: () => import('@/views/core/integral-grade/list'),
        meta: { title: '积分等级列表' }
      },
      {
        path: 'create',
        name: 'coreIntegralGradeCreate',
        component: () => import('@/views/core/integral-grade/form'),
        meta: { title: '新增积分等级' }
      },
      {
        path: 'edit/:id',
        name: 'coreIntegralGradeEdit',
        component: () => import('@/views/core/integral-grade/form'),
        meta: { title: '编辑积分等级' },
        hidden: true
      }
    ]
},
```







### 三、前端开发流程

#### 1、全栈开发流程

##### 1、前端调用流程

下图是开发过程中涉及到和几个核心的模块，我们已经完成了路由的配置和页面组件的创建，接下来我们需要进一步完善页面组件的模板 \<template>部分，以及脚本\<script>等部分的开发，然后创建前后端对接需要的api模块，最后通过api模块向后端接口发起调用。

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205072259818.png)



##### 2、nginx反向代理配置

目前，应用程序的前后端基本架构如下：srb-admin是前端程序，直接调用后端的srb-core微服务

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205080942459.png)

为了能够让前端程序能够同时对接多个后端服务，我们可以使用多种解决方案，例如nginx反向代理、微服务网关等。这里我们先使用nginx作为前后端中间的反向代理层，架构如下

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205080956814.png)



nginx的配置

```nginx
server {
	listen       80;
	server_name  localhost;

	location ~ /core/ {           
	    proxy_pass http://localhost:8110;
	}
	location ~ /sms/ {           
	    proxy_pass http://localhost:8120;
	}
	location ~ /oss/ {           
            proxy_pass http://localhost:8130;
	}
}
```



nginx的命令

```nginx
start nginx #启动
nginx -s stop #停止
nginx -s reload #重新加载配置
```





前端的配置： .env.development

```js
# base api：连接到nginx
VUE_APP_BASE_API = 'http://localhost'
```



##### 3、mock-server



VUE_APP_BASE_API 的 修改会影响到平台模拟登录功能的mock数据，因此需要修改mock-server的地址

修改 mock/mock-server.js 文件 第37行

```js
url: new RegExp(`/dev-api${url}`),
```



修改 src/api/user.js中的接口调用，为每一个远程调用添加配置

```js
baseURL: '/dev-api',
```

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205081822995.png)



#### 2、前端组件开发

##### 1、定义api模块

创建文件 src/api/core/integral-grade.js

```js
// @ 符号在vue.config.js 中配置， 表示 'src' 路径的别名
import request from '@/utils/request'
export default {
  list() {
    return request({
      url: '/admin/core/integralGrade/list',
      method: 'get'
    })
  }
}

```



##### 2、定义页面组件脚本

src/views/core/integral-grade/list.vue

```vue
<script>
import integralGradeApi from '@/api/core/integral-grade'
export default {
  // 定义数据模型
  data() {
    return {
      list: [] // 数据列表
    }
  },

  // 页面渲染成功后获取数据
  created() {
    this.fetchData()
  },

  // 定义方法
  methods: {
    fetchData() {
      // 调用api
      integralGradeApi.list().then(response => {
        this.list = response.data.list
      })
    }
  }
}
</script>
```



##### 3、定义页面组件模板

src/views/core/integral-grade/list.vue

```vue
<template>
  <div class="app-container">
    <!-- 表格 -->
    <el-table :data="list" border stripe>
      <el-table-column type="index" width="50" />
      <el-table-column prop="borrowAmount" label="借款额度" />
      <el-table-column prop="integralStart" label="积分区间开始" />
      <el-table-column prop="integralEnd" label="积分区间结束" />
    </el-table>
  </div>
</template>
```



##### 4、axios响应拦截器修改

src/utils/request.js 中 将第49行的 

```js
if (res.code !== 20000) {
```

修改成

```js
if (res.code !== 0 && res.code !== 20000) {
```



因为我们的后端接口统一结果判断0为成功的响应结果，而mock数据判断20000位正确的结果



##### 

### 四、完善积分模块

#### 1、**删除数据**

##### 1.定义api

 src/api/core/integral-grade.js

```js
removeById(id) {
    return request({
        url: `/admin/core/integralGrade/remove/${id}`,
        method: 'delete'
    })
}
```



##### 2.页面组件模板

src/views/core/integral-grade/list.vue，在table组件中添加<font color ='red'>删除列</font>

```vue
<el-table-column label="操作" width="200" align="center">
    <template slot-scope="scope">
        <el-button
                   type="danger"
                   size="mini"
                   icon="el-icon-delete"
                   @click="removeById(scope.row.id)"
                   >
            删除
        </el-button>
    </template>
</el-table-column>
```



##### 3.删除数据脚本

```js
// 根据id删除数据
    removeById(id) {
      // debugger
      console.log('id', id)

      this.$confirm('此操作将永久删除该记录, 是否继续?', '提示', {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      })
        .then(() => {
          return integralGradeApi.removeById(id)
        })
        .then(response => {
          this.$message({
            message: response.message,
            type: 'success'
          })
          this.fetchData()
        })
        .catch(error => {
          console.log('catch的error', error)
          if (error === 'cancel') {
            this.$message({
              type: 'info',
              message: '已取消删除'
            })
          }
        })
    }
```



#### 2、新增数据

##### 1.定义api

 src/api/core/integral-grade.js

```js
save(integralGrade) {
    return request({
        url: '/admin/core/integralGrade/save',
        method: 'post',
        data: integralGrade
    })
}

```



##### 2.定义页面data

src/views/core/integral-grade/form.vue，完善data定义

```vue
<script>
export default {
  data() {
    return {
      integralGrade: {}, // 初始化数据
      saveBtnDisabled: false // 保存按钮是否禁用，防止表单重复提交
    }
  }
}
</script>

```



##### 3.页面组件模板

src/views/core/integral-grade/form.vue，完善template

```vue
<template>
  <div class="app-container">
    <!-- 输入表单 -->
    <el-form label-width="120px">
      <el-form-item label="借款额度">
        <el-input-number v-model="integralGrade.borrowAmount" :min="0" />
      </el-form-item>
      <el-form-item label="积分区间开始">
        <el-input-number v-model="integralGrade.integralStart" :min="0" />
      </el-form-item>
      <el-form-item label="积分区间结束">
        <el-input-number v-model="integralGrade.integralEnd" :min="0" />
      </el-form-item>
      <el-form-item>
        <el-button :disabled="saveBtnDisabled" type="primary" @click="saveOrUpdate()">
          保存
        </el-button>
      </el-form-item>
    </el-form>
  </div>
</template>
```



##### 4.新增数据脚本

src/views/core/integral-grade/form.vue，引入api

```js
import integralGradeApi from '@/api/core/integral-grade'
```



定义保存方法

```js
methods: {
    saveOrUpdate() {
      // 禁用保存按钮
      this.saveBtnDisabled = true
      this.saveData()
    },

    // 新增数据
    saveData() {
      // debugger
      integralGradeApi.save(this.integralGrade).then(response => {
        this.$message({
          type: 'success',
          message: response.message
        })
        this.$router.push('/core/integral-grade/list')
      })
    }
}

```





#### 3、回显数据

##### 1.列表页编辑按钮

src/views/core/integral-grade/list.vue，表格“操作”列中增加“修改”按钮

```vue
<router-link :to="'/core/integral-grade/edit/' + scope.row.id" style="margin-right:5px;" >
	<el-button type="primary" size="mini" icon="el-icon-edit">
		修改
	</el-button>
</router-link>
```



##### 2.定义api

src/api/core/integral-grade.js

```js
getById(id) {
    return request({
        url: `/admin/core/integralGrade/get/${id}`,
        method: 'get'
    })
}
```



##### 3.获取数据脚本

src/views/core/integral-grade/form.vue，methods中定义回显方法

```js
// 根据id查询记录
fetchDataById(id) {
    integralGradeApi.getById(id).then(response => {
        this.integralGrade = response.data.record
    })
}
```

页面渲染成功后获取数据

因为已在路由中定义如下内容：<font color ='red'>path: 'edit/:id'</font>/，因此可以使用 <font color ='red'>this.$route.params.id</font> 获取路由中的id

```js
//页面渲染成功
created() {
    if (this.$route.params.id) {
        this.fetchDataById(this.$route.params.id)
    }
},
```



#### 4、更新数据

##### 1.定义api

src/api/core/integral-grade.js

```js
updateById(integralGrade) {
    return request({
      url: '/admin/core/integralGrade/update',
      method: 'put',
      data: integralGrade
    })
}
```



##### 2.更新数据脚本

src/views/core/integral-grade/form.vue，methods中定义updateData

```js
// 根据id更新记录
updateData() {
    // 数据的获取
    integralGradeApi.updateById(this.integralGrade).then(response => {
        this.$message({
            type: 'success',
            message: response.message
        })
        this.$router.push('/core/integral-grade/list')
    })
}
```



完善saveOrUpdate方法

```js
saveOrUpdate() {
    // 禁用保存按钮
    this.saveBtnDisabled = true
    if (!this.integralGrade.id) {
        this.saveData()
    } else {
        this.updateData()
    }
},
```



##### 



## 参考地址 ↓



1、Springboot 启动注解扫描：https://blog.csdn.net/m0_50932526/article/details/122936434

<br>

2、异常：org.apache.ibatis.binding.BindingException: Invalid bound statement (not fou

需要指定扫描包路径为具体路径，之前是 **@MapperScan({"com.kk.srb"})**,现在是**@MapperScan({"com.kk.srb.core.mapper"})**

https://www.freesion.com/article/7476436940/



<br>

3、vue项目 出现 `Failed to compile.`

编译错误，可能是指定的路径和文件不匹配

![](https://v1.mykkto.cn/image/blog/2022/project/shangrongbao/202205062355727.png)



<br>

4、 \< 标签开头如果不是成对存在，需用  `\` 转义 